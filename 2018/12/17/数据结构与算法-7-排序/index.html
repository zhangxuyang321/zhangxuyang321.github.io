<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-CN">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">












<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.4">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.4" color="#222">









<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '6.0.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  
  <meta name="keywords" content="笔记,算法," />


<meta name="description" content="如何分析排序算法排序算法的执行效率最好情况,最坏情况,平均情况时间复杂度在分析排序算法的时间复杂度时,要分别给出,最坏,最好,平均情况下的时间复杂度.初次之外还要说出,最好,最坏时间复杂度对应要排序的原始数据是什么样.">
<meta name="keywords" content="笔记,算法">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构与算法(7)_排序">
<meta property="og:url" content="http://yoursite.com/2018/12/17/数据结构与算法-7-排序/index.html">
<meta property="og:site_name" content="zhangxy">
<meta property="og:description" content="如何分析排序算法排序算法的执行效率最好情况,最坏情况,平均情况时间复杂度在分析排序算法的时间复杂度时,要分别给出,最坏,最好,平均情况下的时间复杂度.初次之外还要说出,最好,最坏时间复杂度对应要排序的原始数据是什么样.">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2018-12-21T09:29:39.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据结构与算法(7)_排序">
<meta name="twitter:description" content="如何分析排序算法排序算法的执行效率最好情况,最坏情况,平均情况时间复杂度在分析排序算法的时间复杂度时,要分别给出,最坏,最好,平均情况下的时间复杂度.初次之外还要说出,最好,最坏时间复杂度对应要排序的原始数据是什么样.">






  <link rel="canonical" href="http://yoursite.com/2018/12/17/数据结构与算法-7-排序/"/>



<script type="text/javascript" id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>
  <title>数据结构与算法(7)_排序 | zhangxy</title>
  






  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8087e85c4aa64b0bf3ad5b4a9ed23038";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style type="text/css">
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion {
      .logo-line-before i { left: initial; }
      .logo-line-after i { right: initial; }
    }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">zhangxy</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-home"></i> <br />首页</a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />标签</a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-th"></i> <br />分类</a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />归档</a>
        </li>
      

      
    </ul>
  

  
</nav>


  



 </div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/12/17/数据结构与算法-7-排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="zhangxy">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/head.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="zhangxy">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据结构与算法(7)_排序</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-17T10:06:53+08:00">2018-12-17</time>
            

            
            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/算法/" itemprop="url" rel="index"><span itemprop="name">算法</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="如何分析排序算法"><a href="#如何分析排序算法" class="headerlink" title="如何分析排序算法"></a>如何分析排序算法</h2><h3 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h3><h4 id="最好情况-最坏情况-平均情况时间复杂度"><a href="#最好情况-最坏情况-平均情况时间复杂度" class="headerlink" title="最好情况,最坏情况,平均情况时间复杂度"></a>最好情况,最坏情况,平均情况时间复杂度</h4><p>在分析排序算法的时间复杂度时,要分别给出,最坏,最好,平均情况下的时间复杂度.初次之外还要说出,最好,最坏时间复杂度对应要排序的原始数据是什么样.</p>
<a id="more"></a>
<p>这么区分的原因是:</p>
<ul>
<li>有些排序算法会区分,为了好对比,所以我们最好都区分</li>
<li>对于要排序的数据,有的接近有序,有的完全无序.有序度不同的数据,对于排序的执行时间肯定是有影响的,我们要知道排序算法在不同数据下的性能表现</li>
</ul>
<h4 id="时间复杂度的系数-常数-低阶"><a href="#时间复杂度的系数-常数-低阶" class="headerlink" title="时间复杂度的系数,常数,低阶"></a>时间复杂度的系数,常数,低阶</h4><p>时间复杂度是反应数据规模n很大的时候的一个增长趋势,所以她表示的时候会忽略系数,常数,低阶.但是实际开发中,我们实际的排序数据可能是10个,100个,1000个.所以对同一阶时间复杂度排序算法性能比较的时候,我们就要把系数,常数,低阶也考虑进来.</p>
<h4 id="比较次数和交换-移动"><a href="#比较次数和交换-移动" class="headerlink" title="比较次数和交换(移动)"></a>比较次数和交换(移动)</h4><p>基于比较的排序算法的执行过程,会涉及两种操作,一种是元素比较大小,另一种事元素交换或移动.所以我们在分析排序算法的执行效率的时候,应该把比较次数和交换(移动)次数也考虑进去.</p>
<h3 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h3><p>算法的内存消耗可以通过空间复杂度来衡量,排序算法也不例外.针对排序算法的空间复杂度,我们还引入一个新的概念,<font color="red">原地排序</font>.原地排序算法就是特指空间复杂度是O(1)的排序算法.</p>
<h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>针对排序算法,我们还有一个重要的度量指标,<font color="red">稳定性</font>.这个概念是说,如果排序的序列中存在值相等的元素,经过排序之后,相等元素之间原有的先后顺序不变.</p>
<p>比如我们有一组数据2,9,3,4,8,3.按照大小排序之后是2,3,3,4,8,9.这组数据里有两个3.经过某种排序算法之后,如果两个3的前后顺序没有改变,那么我们就把这种排序算法叫做<font color="red">稳定的排序算法</font>;如果前后顺序发生变化,那对应的排序算法就叫做不稳定排序算法.</p>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = arr.length;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="comment">//提前退出冒泡排序的标志</span></span><br><span class="line">		<span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n-i-<span class="number">1</span>;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j] &gt; a[j+<span class="number">1</span>])&#123;</span><br><span class="line">				<span class="keyword">int</span> tmp = a[j];</span><br><span class="line">				a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">				a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">				flag = <span class="keyword">true</span>; <span class="comment">//表示有数据交换</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(!flag) <span class="keyword">break</span>;	<span class="comment">//没有数据交换,提前退出</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>冒泡排序的过程只涉及相邻数据的交换操作,只需要常量级的临时空间,所以它的空间复杂度为O(1),是<font color="red">原地排序算法</font></li>
<li>在冒泡排序中,只有交换才可以改变两个元素的先后顺序.为了保证冒泡排序算法的稳定性,当有两个元素大小相等的时候,我们不做交换,相同大小的数据在排序前后不会改变顺序,所以冒泡排序是<font color="red">稳定的排序算法</font></li>
<li>冒泡排序的时间复杂度是,最好情况,要排序的数据已经有序了,我们只需要进行一次排序就够了,所以<font color="red">最好情况时间复杂度是O(n)</font>.而最坏的情况是,要排序的数据刚好是倒序排列的,我们需要进行n次冒泡操作,所以<font color="red">最坏时间复杂度是O($$n^2$$)</font>.</li>
</ul>
<h3 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h3><p>对于包含n个数据的数组,这n个数据就有n!种排列方式.不同的排列方式,冒泡排序的执行时间肯定是不同的.如果用概率论方法定量分析平均时间复杂度,设计数学推理和计算会很复杂.我们通过<font color="red">有序度</font>和<font color="red">逆序度</font>,这两个概念来分析.</p>
<font color="red">有序度</font>是数组中具有关系元素对的个数.有序元素对用数学表达式就是: a[i] &lt;= a[j], 如果i &lt; j;  例如图:<br><br>同理,对于一个倒序排列的数组,比如6,5,4,3,2,1,有序度是0;对于一个完全有序的数组,比如1,2,3,4,5,6有序度就是n<em>(n-1)/2,也就是15.我们把这种完全有序的数组的有序度叫做<font color="red">满有序度</font>.<br><br><font color="red">逆序度</font>的定义正好跟有序度相反(默认从小到大为有序).即: a[i] &gt; a[j], 其中i&lt;j;<br><br>关于这三个概念,我们还可以得到一个公式: <font color="red">逆序度=满有序度-有序度</font>.我们排序的过程就是一种增加有序度,减少逆序度的过程,最后达到满有序度.<br><br>冒泡排序包含两个操作原子,比较和交换.每交换一次,有序度就加1.不管怎么改进算法,交换的次数总是确定的,即为逆序度,也就是n </em> (n-1)/2–初始有序度.对于包含n个数据的数组进行冒泡排序,初始状态的有序度是0,所以要进行n <em> (n-1)/2次交换.最好情况下有序度是n </em> (n-1)/2.就不需要进行交换.所以平均情况下,需要n * (n-1)/4次交换操作,比较操作肯定要比交换操作多,而复杂度的上限是O($$n^2$$),所以<font color="red">平均情况时间复杂度为O($$n^2$$)</font>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>首先我们将数组中的数据分为两个区间,<font color="red">已排序区间</font>和<font color="red">未排序区间</font>.初始已排序区间就是数组的第一个元素.插入算法的核心思想就是取未排序区间的元素,在已排序区间找到合适的位置插入,并保证已排序区间一直有序.重复这个过程,直到排序完成.</p>
<p>插入排序也包含两种操作,一种是元素比较,一种是元素移动.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = arr.length;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="keyword">int</span> value = arr[i];</span><br><span class="line">		<span class="keyword">int</span> j = i-<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(;j&gt;=<span class="number">0</span>;--j)&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[j] &gt; value)&#123;</span><br><span class="line">				a[j+<span class="number">1</span>] = a[j]; <span class="comment">//数据移动</span></span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		a[j+<span class="number">1</span>] = value; <span class="comment">//插入数据</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>插入排序算法并不需要额外存储空间,所以它的空间复杂度为O(1),是<font color="red">原地排序算法</font></li>
<li>对于值相同的元素我们可以选择将后面出现的元素,插入到前面元素的后面,这样就可以保持原有的前后顺序不变,所以插入排序是<font color="red">稳定的排序算法</font></li>
<li>插入排序的时间复杂度. 如果排序的数据是有序的,我们并不需要搬移任何数据.如果我们从尾到头在有序的数据组里查找插入位置,每次只要比较一个数据就能确定位置,所以这种情况下<font color="red">最好时间复杂度是O(n)</font>.注意是<font color="red">从尾到头遍历已经有序的数据</font>.如果数组是倒序的,每次插入都相当于在数组的第一个位置插入新的数据.所以<font color="red">最坏情况时间复杂度为O($$n^2$$)</font>.数组中插入一个数据的平均时间复杂度是O(n),对于插入排序来说,每次插入操作都相当于在数组中插入一个数据,循环执行n次插入操作,所以<font color="red">平均时间复杂度为($$n^2$$)</font>.</li>
</ul>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序算法的实现思路类似插入排序,也分已排序区间和未排序区间.但是选择排序每次会从未排序区间找到最小的元素,将其放到已排序区间的末尾.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = arr.length;</span><br><span class="line">	<span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		<span class="comment">//查找最小值</span></span><br><span class="line">		<span class="keyword">int</span> minIndex = i;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(arr[j] &lt; arr[minIndex])&#123;</span><br><span class="line">				minIndex = j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//交换</span></span><br><span class="line">		<span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">		arr[i] = arr[minIndex];</span><br><span class="line">		arr[minIndex] = tmp;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>选择排序的空间复杂度为O(1),也是原地排序算法.</li>
<li>选择排序是一种不稳定的排序算法</li>
<li>选择排序最好,最坏,平均时间复杂度都是O($$n^2$$).</li>
</ul>
<h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序的核心思想是<font color="red">分治思想</font>.如果要排序一个数组,我们先把数组从中间分成前后两部分,然后对前后两部分分别排序,再将排好序的两部分合并在一起.这样整个数组就有序了.</p>
<p>分治思想.分治,顾名思义,就是分而治之,将一个大问题分解成小的子问题来解决.分治思想跟递归思想很像.分治算法一般都是用递归来实现的.<font color="red">分治是一种解决问题的处理思想,递归是一种编程技巧</font>.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a 待排序的数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> p  排序的起点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> r  排序的终点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mergeSortInternally</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="comment">//递归终止条件</span></span><br><span class="line">	<span class="keyword">if</span>(p&gt;=r) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> q = (p + r)/<span class="number">2</span></span><br><span class="line">	mergeSortInternally(a,p,q);</span><br><span class="line">	mergeSortInternally(a,q+<span class="number">1</span>,r);</span><br><span class="line">	merge(a,p,q,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a,<span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i = p;</span><br><span class="line">	<span class="keyword">int</span> j = q+<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r-p+<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(i&lt;=q &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[i] &lt; a[j])&#123;</span><br><span class="line">			tmp[k++] = a[i++];</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			tmp[k++] = a[j++];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> start = i;</span><br><span class="line">	<span class="keyword">int</span> end = q;</span><br><span class="line">	<span class="keyword">if</span>(j&lt;=r)&#123;</span><br><span class="line">		start = j;</span><br><span class="line">		end = r;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(start&lt;=end)&#123;</span><br><span class="line">		tmp[k++] = tmp[start++];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;=r-p;i++)&#123;</span><br><span class="line">		a[p+i] = tmp[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序性能分析"><a href="#归并排序性能分析" class="headerlink" title="归并排序性能分析"></a>归并排序性能分析</h3><h4 id="归并排序是稳定的排序算法吗"><a href="#归并排序是稳定的排序算法吗" class="headerlink" title="归并排序是稳定的排序算法吗"></a>归并排序是稳定的排序算法吗</h4><p>归并排序稳不稳定关键需要看merge方法.在合并过程中如果a[p….q]和a[q+1….r]之间有值相同的元素,那我们可以像代码中那样,先把a[p….q]中的元素放入tmp数组中.这样就保证了值相同的元素,在合并前后的先后顺序不变.所以,归并排序<font color="red">是一个稳定排序算法</font></p>
<h4 id="归并排序的时间复杂度是多少"><a href="#归并排序的时间复杂度是多少" class="headerlink" title="归并排序的时间复杂度是多少"></a>归并排序的时间复杂度是多少</h4><p>归并排序的时间复杂度,不管是最好情况,最坏情况,还是平均情况时间复杂度都是O(nlogn)</p>
<h4 id="归并排序的空间复杂度"><a href="#归并排序的空间复杂度" class="headerlink" title="归并排序的空间复杂度"></a>归并排序的空间复杂度</h4><p>空间复杂度是O(n).</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序算法,利用的也是分治思想.乍看起来,它有点想归并排序,但是思路其实是不一样的.</p>
<p>快速排序的思想:如果要排序数组中下标从p到r之间的一组数据,我们选择p到r之间的任意一个数据作为pivot(分区点).我们遍历p到r之间的数据,将小于pivot的放在左边,将大于pivot的放到右边,将pivot放到中间.</p>
<p>经过这么处理之后数据就被分成了3个部分,前面p到q-1之间都是小于pivot的.中间是pivot,后面的q+1到r之间是大于pivot的.</p>
<p>根据分治,递归处理思想,我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从q+1 到 r 之间的数据，直到区间缩小为 1，就说明所有的数据有序了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> a 待排序的数组</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> p  排序的起点</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> r  排序的终点</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p&gt;=q) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">int</span> q = partition(a,p,r);</span><br><span class="line">	quickSort(a,p,q-<span class="number">1</span>);</span><br><span class="line">	quickSort(a,q+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pivot = a[r];</span><br><span class="line">	<span class="keyword">int</span> i = p;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> j=p; j&lt;r; j++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(a[j] &lt; pivot)&#123;</span><br><span class="line">			<span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">			arr[i] = arr[j];</span><br><span class="line">			arr[j] = tmp;</span><br><span class="line">			i++;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">	arr[i] = arr[r];</span><br><span class="line">	arr[r] = tmp;</span><br><span class="line">	<span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>快速排序是一个不稳定排序算法,但是原地排序算法.</p>
<p>快速排序的时间复杂度也是O(nlogn),但是在极端状态下,比如1,3,5,6,8.如果我们每次都选择最后一个元素作为pivot,那每次分区得到的两个区间都是不均等的,我们需要进行大约n次操作,才能完成快排的整个过程,每次分区平均要扫码大约n/2个元素,这种情况下快排的时间复杂度就从O(nlogn)退化成了O($$n^2$$).</p>
<h2 id="归并排序与快速排序的区别"><a href="#归并排序与快速排序的区别" class="headerlink" title="归并排序与快速排序的区别"></a>归并排序与快速排序的区别</h2><p>//todo 图片7</p>
<font color="red">归并排序</font>处理过程是<font color="red">由下到上</font>的,先处理子问题,最后再合并.而<font color="red">快速排序</font>正好相反,它的处理过程是<font color="red">由上到下</font>的,先区分,然后再处理子问题. 归并排序虽然是稳定的,时间复杂度为O(nlogn)的<br><br>## 线性排序<br>桶排序,计数排序,基数排序,这些排序算法的时间复杂度是线性的,我们把这类排序算法称为<font color="red">线性排序</font>

<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><p>桶排序,顾名思义,会用到”桶”,核心思想是将要排序的数据分到几个有序的桶里,每个桶里的数据再单独进行排序.桶内排序之后,再把每个桶里的数据按照顺序依次取出,组成的序列就是有序的了</p>
<p>桶排序的时间复杂度是O(n).</p>
<h4 id="桶排序特点及适用场景"><a href="#桶排序特点及适用场景" class="headerlink" title="桶排序特点及适用场景"></a>桶排序特点及适用场景</h4><p>桶排序对数据的要求非常苛刻. </p>
<p>首先要排序的数据需要很容易划分成m个桶,并且桶与桶之间有着天然的大小顺序</p>
<p>其次,数据在各个桶之间的分布是比较均匀的.如果分布不均,那时间复杂度就不是O(n)了.极端情况下,都分布到一个桶里,时间复杂度就退化到O(nlogn)了</p>
<p><font color="red">桶排序比较适合用在外部排序中</font>.所为的外部排序就是数据存储在外部磁盘中,数据量比较大,内存有限,无法将全部数据加载到内存中</p>
<h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>个人感觉,<font color="red">计数排序是桶排序的一种特殊情况</font>.当要排序的n个数据,所处的范围并不大的时候,比如最大值k,我们就可以把数据化成k个桶,每个桶内的数据值都是相同的,省掉了桶内排序的时间.</p>
<p>假设有8个考生,分数在0~5之间.这个考生的分数放在一个数组A[8]中,分别是A[8]={2,5,3,0,2,3,0,3}.</p>
<p>考生的成绩从0到5,我们使用大小为6的数组C[6]表示桶,其中<font color="red">下标对应分数,存储对应分数的考生的个数</font>,此时<br>C[6]={2,0,2,3,0,1}.</p>
<p>那我们如何快速计算出,每个分数的考生在有序数组R中对应的位置呢?</p>
<p>思路是这样的:<font color="red">我们对C[6]数组求和,计算出小于等于某个分数的人数.</font>即C[k]里存储小于等于分数k的考生个数.此时C[6]={2,2,4,7,7,8}.</p>
<p>我们依次从后到前扫描数组A,比如当扫描到3时,我们可以从数组C中去除下标为3的值7,也就是说到目前未知,包括自己在内,分数小于等于3 的考生有7个,也就是说3是数组R中的第7个元素(也就是R数组下标为6的位置),当3放入到数组R中后,小于等于3的就只剩下6个了,所以相应的C(3)要减1,变成6.</p>
<p>一次类推,当我们扫描完整个数组A后,数组R内的数据就是安装分数从小到大的有序排列了.</p>
<p>//todo 如图8</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountingSort</span></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 计数排序</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@param</span> a 排序数组</span></span><br><span class="line"><span class="comment">	* <span class="doctag">@param</span> n 数组大小,不需要减1</span></span><br><span class="line"><span class="comment">	* 假设数组中存储的都是非负整数</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//查找数组中的数据范围</span></span><br><span class="line">		<span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">			<span class="keyword">if</span>(max&lt;a[i])&#123;</span><br><span class="line">				max = 	a[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//申请一个计数数组c,下标大小[0,max]</span></span><br><span class="line">		<span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;max+<span class="number">1</span>;i++)&#123;</span><br><span class="line">			c[i] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//计算每个元素的个数,放入数组C中</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			c[a[i]]++;</span><br><span class="line">		&#125;	</span><br><span class="line">	</span><br><span class="line">		<span class="comment">//依次累加</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;max+<span class="number">1</span>;i++)&#123;</span><br><span class="line">			c[i] = c[i-<span class="number">1</span>]+c[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//临时数组r,存储排序之后的结果</span></span><br><span class="line">		<span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">		<span class="comment">//计数排序的关键步骤</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i= n-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">			<span class="keyword">int</span> index = c[a[i]] - <span class="number">1</span>;</span><br><span class="line">			r[index] = a[i];</span><br><span class="line">			c[a[i]]--;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//将结果拷贝回原数组</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">			a[i] = r[i];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计数排序只能用在数据防卫不大的数据当中,如果数据范围k比要排序的数据n大很多,就不适合用计数排序了.而且计数排序只能给非负整数排序,如果要排序的数据是其他类型的,要将其在不改变其大小的情况下,转化为非负整数.</p>
<h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><p>基数排序对要排序的数据是有要求的,需要可以分割出独立的”位”来比较,而且位之间有递进关系,如果a数据的高位比b数据大,那剩下的低位就不用比较了.除此之外每一位的数据范围不能太大,要可以用线性排序算法来排序,否则基数排序的算法时间复杂度就不会是O(n)了.</p>
<p>假如我们有10万个手机号码,从小到大排序,手机号码有11位,范围太大,显然不适合桶排序和计数排序.针对这个问题要使用基数排序.</p>
<p>借助稳定排序算法,先按照最后一位来排序手机号,然后再照倒数第二位来排序,以此类推经过11次排序后,手机号码就有序了</p>
<p>注意要按每位来排序的排序算法要稳定的.根据每一位来排序,我们可以根据桶排序或者计数排序,他们的时间复杂度可以做到O(n),如果要排序k次,总的时间复杂度就是O(k*n).k在这里最大就11,所以可以做到近似O(n).</p>

      
    </div>

    

    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/笔记/" rel="tag"># 笔记</a>
          
            <a href="/tags/算法/" rel="tag"># 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/12/13/数据结构与算法-6-递归/" rel="next" title="数据结构与算法(6)_递归">
                <i class="fa fa-chevron-left"></i> 数据结构与算法(6)_递归
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/12/24/数据结构与算法-8-二分查找/" rel="prev" title="数据结构与算法(8)_二分查找">
                数据结构与算法(8)_二分查找 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/head.jpg"
                alt="zhangxy" />
            
              <p class="site-author-name" itemprop="name">zhangxy</p>
              <p class="site-description motion-element" itemprop="description">路漫漫其修远兮</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">33</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">13</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  <a href="https://github.com/zhangxuyang321" target="_blank" title="GitHub">GitHub</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="zhangxuyang321@gmail.com" target="_blank" title="E-Mail">E-Mail</a>
                  
                </span>
              
                <span class="links-of-author-item">
                  <a href="https://weibo.com/u/5207372383/home" target="_blank" title="微博">微博</a>
                  
                </span>
              
            </div>
          

          
          

          
          

          
            
          
          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#如何分析排序算法"><span class="nav-number">1.</span> <span class="nav-text">如何分析排序算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法的执行效率"><span class="nav-number">1.1.</span> <span class="nav-text">排序算法的执行效率</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最好情况-最坏情况-平均情况时间复杂度"><span class="nav-number">1.1.1.</span> <span class="nav-text">最好情况,最坏情况,平均情况时间复杂度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间复杂度的系数-常数-低阶"><span class="nav-number">1.1.2.</span> <span class="nav-text">时间复杂度的系数,常数,低阶</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较次数和交换-移动"><span class="nav-number">1.1.3.</span> <span class="nav-text">比较次数和交换(移动)</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法的内存消耗"><span class="nav-number">1.2.</span> <span class="nav-text">排序算法的内存消耗</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#排序算法的稳定性"><span class="nav-number">1.3.</span> <span class="nav-text">排序算法的稳定性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序"><span class="nav-number">2.</span> <span class="nav-text">冒泡排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#平均时间复杂度"><span class="nav-number">2.1.</span> <span class="nav-text">平均时间复杂度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序"><span class="nav-number">3.</span> <span class="nav-text">插入排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序"><span class="nav-number">4.</span> <span class="nav-text">选择排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序"><span class="nav-number">5.</span> <span class="nav-text">归并排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#归并排序性能分析"><span class="nav-number">5.1.</span> <span class="nav-text">归并排序性能分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#归并排序是稳定的排序算法吗"><span class="nav-number">5.1.1.</span> <span class="nav-text">归并排序是稳定的排序算法吗</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归并排序的时间复杂度是多少"><span class="nav-number">5.1.2.</span> <span class="nav-text">归并排序的时间复杂度是多少</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#归并排序的空间复杂度"><span class="nav-number">5.1.3.</span> <span class="nav-text">归并排序的空间复杂度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序"><span class="nav-number">6.</span> <span class="nav-text">快速排序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序与快速排序的区别"><span class="nav-number">7.</span> <span class="nav-text">归并排序与快速排序的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#桶排序"><span class="nav-number">7.1.</span> <span class="nav-text">桶排序</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#桶排序特点及适用场景"><span class="nav-number">7.1.1.</span> <span class="nav-text">桶排序特点及适用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计数排序"><span class="nav-number">7.2.</span> <span class="nav-text">计数排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基数排序"><span class="nav-number">7.3.</span> <span class="nav-text">基数排序</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhangxy</span>

  

  
</div>




  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/theme-next/hexo-theme-next">NexT.Mist</a> v6.0.4</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.4"></script>



  



	





  





  










  





  

  

  

  

  
  

  

  

  

  

</body>
</html>
